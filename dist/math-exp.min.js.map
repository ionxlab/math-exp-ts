{"version":3,"file":"math-exp.min.js","mappings":"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","sources":["webpack://math-exp/webpack/universalModuleDefinition","webpack://math-exp/./src/core/ExpressionBuilder.ts","webpack://math-exp/./src/core/ExpressionParser.ts","webpack://math-exp/./src/exceptions/BracketsMissmatchException.ts","webpack://math-exp/./src/exceptions/DivisionByZeroException.ts","webpack://math-exp/./src/exceptions/EmptyExpressionException.ts","webpack://math-exp/./src/exceptions/EmptyExpressionStringException.ts","webpack://math-exp/./src/exceptions/EvaluateException.ts","webpack://math-exp/./src/exceptions/MissingOperandException.ts","webpack://math-exp/./src/exceptions/MissingTermException.ts","webpack://math-exp/./src/exceptions/ParserException.ts","webpack://math-exp/./src/exceptions/UndefinedExpressionStringException.ts","webpack://math-exp/./src/expression/abstract/OperandAbstract.ts","webpack://math-exp/./src/expression/abstract/OperatorAbstract.ts","webpack://math-exp/./src/expression/abstract/OperatorFunctionAbstract.ts","webpack://math-exp/./src/expression/abstract/OperatorLeftRightAbstract.ts","webpack://math-exp/./src/expression/abstract/TermAbstract.ts","webpack://math-exp/./src/expression/core/Expression.ts","webpack://math-exp/./src/expression/core/Variables.ts","webpack://math-exp/./src/expression/core/index.ts","webpack://math-exp/./src/expression/index.ts","webpack://math-exp/./src/expression/operands/Constant.ts","webpack://math-exp/./src/expression/operands/Variable.ts","webpack://math-exp/./src/expression/operands/index.ts","webpack://math-exp/./src/expression/operators/arithmetic/Divide.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Exponent.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Minus.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Multiply.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Plus.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/index.ts","webpack://math-exp/./src/expression/operators/bitwise/And.operator.ts","webpack://math-exp/./src/expression/operators/bitwise/Or.operator.ts","webpack://math-exp/./src/expression/operators/bitwise/Xor.operator.ts","webpack://math-exp/./src/expression/operators/bitwise/index.ts","webpack://math-exp/./src/expression/operators/function/Cos.operator.ts","webpack://math-exp/./src/expression/operators/function/Ln.operator.ts","webpack://math-exp/./src/expression/operators/function/Log.operator.ts","webpack://math-exp/./src/expression/operators/function/Sin.operator.ts","webpack://math-exp/./src/expression/operators/function/SquareRoot.operator.ts","webpack://math-exp/./src/expression/operators/function/Tan.operator.ts","webpack://math-exp/./src/expression/operators/function/index.ts","webpack://math-exp/./src/expression/operators/index.ts","webpack://math-exp/./src/index.ts","webpack://math-exp/webpack/bootstrap","webpack://math-exp/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"math-exp\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math-exp\"] = factory();\n\telse\n\t\troot[\"math-exp\"] = factory();\n})(this, function() {\nreturn ","import {TermAbstract} from \"../expression/abstract/TermAbstract\";\r\nimport {Expression} from \"../expression\";\r\n\r\n\r\nexport class ExpressionBuilder {\r\n\r\n  private expression: Expression = new Expression();\r\n\r\n  constructor(...terms: TermAbstract[]) {\r\n    this.expression.terms = this.expression.terms.concat(terms);\r\n    this.expression.brackets = false;\r\n  }\r\n\r\n  add(term: TermAbstract, index?: number): number {\r\n    if(index!==undefined)\r\n      this.expression.terms.splice(index, 0, term);\r\n    else\r\n      this.expression.terms.push(term);\r\n\r\n    return this.expression.terms.length;\r\n  }\r\n\r\n  addAll(...terms: TermAbstract[]) {\r\n    this.expression.terms = this.expression.terms.concat(terms);\r\n  }\r\n\r\n  remove(index): Expression {\r\n    if(index>=0 && index<this.expression.terms.length)\r\n      this.expression.terms.splice(index, 1);\r\n\r\n    return this.expression;\r\n  }\r\n\r\n  getExpression(): Expression {\r\n    return this.expression;\r\n  }\r\n\r\n  clear() {\r\n    this.expression.terms = [];\r\n  }\r\n}","import {Expression, MultiplyOperator} from \"../expression\";\r\nimport {Constant, Variable} from \"../expression\";\r\nimport * as Operators from \"../expression/operators\";\r\nimport {BracketsMissmatchException} from \"../exceptions/BracketsMissmatchException\";\r\nimport {TermAbstract} from \"../expression/abstract/TermAbstract\";\r\nimport {EmptyExpressionStringException} from \"../exceptions/EmptyExpressionStringException\";\r\nimport {UndefinedExpressionStringException} from \"../exceptions/UndefinedExpressionStringException\";\r\nimport {ParserException} from \"../exceptions/ParserException\";\r\n\r\nconst OperatorKeys = Object.keys(Operators);\r\n\r\nexport class ExpressionParser {\r\n  private expressionStr: (string | undefined);\r\n\r\n  constructor(expressionStr?: string) {\r\n    this.expressionStr = expressionStr;\r\n  }\r\n\r\n  setExpressionStr(expressionStr?: string) {\r\n    this.expressionStr = expressionStr;\r\n  }\r\n\r\n  parse(expressionStr?: string): Expression {\r\n    if(expressionStr !== undefined)\r\n      this.setExpressionStr(expressionStr);\r\n\r\n    // check expression string\r\n    if(!this.expressionStr)\r\n      throw new UndefinedExpressionStringException();\r\n    if(this.expressionStr == \"\")\r\n      throw new EmptyExpressionStringException();\r\n\r\n    // parse all elements from expression string\r\n    const matches = this.expressionStr.match(/[a-z0-9]+|[+\\-*\\/()^]|[&|]+/gi);\r\n\r\n    // check number of brackets\r\n    const leftBrackets = matches.filter(value => value=='(');\r\n    const rightBrackets = matches.filter(value => value==')');\r\n    if(leftBrackets.length !== rightBrackets.length)\r\n      throw new BracketsMissmatchException();\r\n\r\n    // create a depth array for nested expressions\r\n    let exp = new Expression();\r\n    const expStack = new Array<Expression>();\r\n    expStack.push(exp);\r\n\r\n    // iterate over all expression term elements\r\n    matches.forEach((elem, index) => {\r\n      const currentExp = expStack[expStack.length-1];\r\n\r\n      // parse elem and return a TermAbstract\r\n      const term = ExpressionParser.parseElem(elem, currentExp);\r\n      if(!term)\r\n        throw new ParserException(\"Unknown element: [\"+elem+\"]\");\r\n\r\n      // if term is an Expression\r\n      if(term instanceof Expression) {\r\n        // if expression is not the current expression, push to expression stack\r\n        if(term !== currentExp) {\r\n          expStack.push(term);\r\n        // else the expression is closed, remove from stack\r\n        } else {\r\n          expStack.pop();\r\n        }\r\n      }\r\n    });\r\n\r\n    return exp;\r\n  }\r\n\r\n  private static parseElem(elem: string, currentExpression: Expression): TermAbstract {\r\n    let term;\r\n\r\n    // if elem matches a numerical constant [0-9]+\r\n    let match = elem.match(/^[0-9]+$/i);\r\n    if(match) {\r\n      term = new Constant(parseFloat(elem));\r\n      currentExpression.terms.push(term);\r\n      return term;\r\n    }\r\n\r\n    // if elem matches a left bracket with a coefficient\r\n    match = elem.match(/^([0-9]*)\\($/i);\r\n    if(match) {\r\n      if(match[1]) {\r\n        currentExpression.terms.push(new Constant(parseFloat(match[1])));\r\n        currentExpression.terms.push(new MultiplyOperator());\r\n      }\r\n\r\n      term = new Expression();\r\n      currentExpression.terms.push(term);\r\n      return term;\r\n    }\r\n\r\n    // if elem matches a right bracket\r\n    match = elem.match(/^\\)$/i);\r\n    if(match) {\r\n      return currentExpression;\r\n    }\r\n\r\n    // if match a named variable with a coefficient\r\n    match = elem.match(/^([0-9]*)([a-z]+)$/i);\r\n    if(match) {\r\n      if(match[1].length>0) {\r\n        currentExpression.terms.push(new Constant(parseFloat(match[1])));\r\n        currentExpression.terms.push(new MultiplyOperator());\r\n      }\r\n\r\n      // if elem matches an operator\r\n      // iterate over all operators\r\n      for(const key of OperatorKeys){\r\n        const Operator = Operators[key];\r\n        // iterate over all operator names\r\n        for(const name of Operator.names) {\r\n          // if name matches, return the constructed operator\r\n          if(name === match[2]) {\r\n            term = new Operators[key]();\r\n            currentExpression.terms.push(term);\r\n            return term;\r\n          }\r\n        }\r\n      }\r\n\r\n      // it's just a variable\r\n      term = new Variable(match[2]);\r\n      currentExpression.terms.push(term);\r\n      return term;\r\n    }\r\n  }\r\n}\r\n","import {ParserException} from \"./ParserException\";\r\n\r\nexport class BracketsMissmatchException extends ParserException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {EvaluateException} from \"./EvaluateException\";\r\n\r\nexport class DivisionByZeroException extends EvaluateException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {EvaluateException} from \"./EvaluateException\";\r\n\r\nexport class EmptyExpressionException extends EvaluateException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {ParserException} from \"./ParserException\";\r\n\r\nexport class EmptyExpressionStringException extends ParserException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","\r\n\r\nexport class EvaluateException extends Error {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {MissingTermException} from \"./MissingTermException\";\r\n\r\nexport class MissingOperandException extends MissingTermException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {EvaluateException} from \"./EvaluateException\";\r\n\r\nexport class MissingTermException extends EvaluateException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","\r\n\r\nexport class ParserException extends Error {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {ParserException} from \"./ParserException\";\r\n\r\nexport class UndefinedExpressionStringException extends ParserException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {TermAbstract} from \"./TermAbstract\";\r\n\r\n\r\nexport abstract class OperandAbstract extends TermAbstract {\r\n\r\n  readonly precedence: number = 0;\r\n  protected _brackets: boolean = false;\r\n\r\n  constructor(brackets?: boolean) {\r\n    super();\r\n    if(brackets !== undefined)\r\n      this._brackets = brackets;\r\n  }\r\n\r\n  get brackets() {\r\n    return this._brackets;\r\n  }\r\n\r\n  set brackets(active: boolean) {\r\n    this._brackets = active;\r\n  }\r\n\r\n  abstract evaluate(): number ;\r\n}","import {TermAbstract} from \"./TermAbstract\";\r\n\r\n\r\nexport abstract class OperatorAbstract extends TermAbstract {\r\n\r\n  abstract readonly names: Array<string>;\r\n\r\n  toString(nameId?:number): string {\r\n    let id = 0;\r\n    if(nameId !== undefined && nameId >= 0 && nameId < this.names.length)\r\n      id = 0;\r\n    return this.names[id];\r\n  };\r\n}","import {OperatorAbstract} from \"./OperatorAbstract\";\r\nimport {Constant} from \"../operands\";\r\n\r\nexport abstract class OperatorFunctionAbstract extends OperatorAbstract {\r\n\r\n  readonly precedence: number = 18;\r\n\r\n  abstract evaluate(param: Constant): number ;\r\n}","import {OperatorAbstract} from \"./OperatorAbstract\";\r\nimport {Constant} from \"../operands\";\r\n\r\nexport abstract class OperatorLeftRightAbstract extends OperatorAbstract {\r\n\r\n  abstract evaluate(left: Constant, right: Constant): number ;\r\n}","\r\n\r\nexport abstract class TermAbstract {\r\n\r\n  abstract readonly precedence: number;\r\n  abstract toString(nameId?: number): string;\r\n}","import {OperatorAbstract} from \"../abstract/OperatorAbstract\";\r\nimport {OperandAbstract} from \"../abstract/OperandAbstract\";\r\nimport {TermAbstract} from \"../abstract/TermAbstract\";\r\nimport {OperatorLeftRightAbstract} from \"../abstract/OperatorLeftRightAbstract\";\r\nimport {OperatorFunctionAbstract} from \"../abstract/OperatorFunctionAbstract\";\r\nimport {Constant, Variable} from \"../operands\";\r\nimport {MissingTermException} from \"../../exceptions/MissingTermException\";\r\nimport {MissingOperandException} from \"../../exceptions/MissingOperandException\";\r\nimport {EmptyExpressionException} from \"../../exceptions/EmptyExpressionException\";\r\nimport {EvaluateException} from \"../../exceptions/EvaluateException\";\r\n\r\nexport class Expression extends TermAbstract {\r\n  public static debug = false;\r\n  readonly precedence: number = 19;\r\n\r\n  private _brackets: boolean = true;\r\n  private _terms: Array<TermAbstract> = new Array<TermAbstract>();\r\n\r\n  constructor(...terms: TermAbstract[]) {\r\n    super();\r\n    if(terms !== undefined)\r\n      this._terms = this._terms.concat(terms);\r\n  }\r\n\r\n  get terms(): Array<TermAbstract> {\r\n    return this._terms;\r\n  }\r\n\r\n  set terms(value: Array<TermAbstract>) {\r\n    this._terms = value;\r\n  }\r\n\r\n  get brackets() {\r\n    return this._brackets;\r\n  }\r\n\r\n  set brackets(active: boolean) {\r\n    this._brackets = active;\r\n  }\r\n\r\n  evaluate(): number {\r\n\r\n    // check terms\r\n    if(this._terms.length==0)\r\n      throw new EmptyExpressionException();\r\n\r\n    Expression.Log(\"Evaluating:\", this.toString());\r\n\r\n    // make a clone for editing\r\n    let temp = this.clone();\r\n    let tempStr = temp.toString();\r\n\r\n    // loop until one constant is left\r\n    while(temp._terms.length>1 || !(temp._terms[0] instanceof Constant)) {\r\n\r\n      let highest = -1;\r\n      let highestId = -1;\r\n      // iterate over all terms and evaluate highest precedence\r\n      temp._terms.forEach((t, id) => {\r\n        if(t.precedence>highest) {\r\n          highest = t.precedence;\r\n          highestId = id;\r\n        }\r\n      });\r\n      Expression.evaluateTerm(temp, highestId);\r\n      Expression.Log(\"Temporary expression:\", temp.toString());\r\n\r\n      if(temp._terms.length>1 && tempStr === temp.toString())\r\n        throw new EvaluateException(\"Error while evaluating.\");\r\n\r\n      tempStr = temp.toString();\r\n    }\r\n\r\n    return (temp._terms[0] as OperandAbstract).evaluate();\r\n  }\r\n\r\n  private static evaluateTerm(expression: Expression, index: number): Expression {\r\n\r\n    const term = expression._terms[index];\r\n    Expression.Log(\"Evaluating Term:\", term.toString());\r\n\r\n    let value = 0;\r\n    if(!term)\r\n      throw new MissingTermException(\"Term at '\"+index+\"' is missing.\");\r\n\r\n    if(term instanceof Expression) {\r\n      Expression.Log(\"Term is an 'Expression'\");\r\n      value = term.evaluate();\r\n      expression._terms[index] = new Constant(value, true);\r\n\r\n      // handle coefficients\r\n      const left = expression._terms[index-1];\r\n      if(left instanceof Expression || left instanceof OperandAbstract) {\r\n        const leftValue = left.evaluate();\r\n\r\n        expression._terms[index] = new Constant(value*leftValue);\r\n        expression._terms.splice(index-1, 1);\r\n      }\r\n\r\n    } else if(term instanceof OperandAbstract) {\r\n      if(term instanceof Constant)\r\n        Expression.Log(\"Term is a 'Constant'\");\r\n      if(term instanceof Variable)\r\n        Expression.Log(\"Term is a 'Variable'\");\r\n\r\n      value = term.evaluate();\r\n      expression._terms[index] = new Constant(value, term.brackets);\r\n\r\n    } else if(term instanceof OperatorAbstract) {\r\n\r\n      if(term instanceof OperatorLeftRightAbstract) {\r\n        Expression.Log(\"Term is an 'OperatorLeftRight'\");\r\n        const left = expression._terms[index-1];\r\n        const right = expression._terms[index+1];\r\n\r\n        if(!(left instanceof Constant))\r\n          throw new MissingOperandException(\"Operator '\"+term.toString()+\"' left argument '\"+left.toString()+\"' is invalid.\");\r\n        if(!(right instanceof Constant))\r\n          throw new MissingOperandException(\"Operator '\"+term.toString()+\"' right argument '\"+right.toString()+\"' is invalid.\");\r\n\r\n        value = term.evaluate(left, right);\r\n\r\n        Expression.Log(\"Evaluated Value: \", value);\r\n\r\n        expression._terms[index] = new Constant(value);\r\n        expression._terms.splice(index+1, 1);\r\n        expression._terms.splice(index-1, 1);\r\n\r\n      } else if(term instanceof OperatorFunctionAbstract) {\r\n        Expression.Log(\"Term is an 'OperatorFunction'\");\r\n        const param = expression._terms[index+1];\r\n\r\n        if(!(param instanceof Constant))\r\n          throw new MissingOperandException(\"Operator '\"+term.toString()+\"' argument '\"+param.toString()+\"' is invalid.\");\r\n\r\n        value = term.evaluate(param);\r\n        expression._terms[index] = new Constant(value);\r\n        expression._terms.splice(index+1, 1);\r\n      } else {\r\n        Expression.Log(\"Unknown operator term ?\");\r\n      }\r\n    } else {\r\n      Expression.Log(\"Unknown term ?\");\r\n    }\r\n\r\n    return expression;\r\n  }\r\n\r\n  private static Log(...args: Object[]) {\r\n    if(Expression.debug)\r\n      console.log.apply(console, args);\r\n  }\r\n\r\n  clone(): Expression {\r\n    let clone = new Expression();\r\n    clone.brackets = this.brackets;\r\n    clone._terms = clone._terms.concat(this._terms);\r\n    return clone;\r\n  }\r\n\r\n  toString(): string {\r\n    let str = \"\";\r\n    this._terms.forEach((t, id) => {\r\n      str += t.toString();\r\n    });\r\n    if(this.brackets)\r\n      str = \"(\"+str+\")\";\r\n    return str;\r\n  }\r\n}","\r\n\r\nexport class Variables {\r\n  static map =  new Map<string, number>([\r\n    ['a', 0],\r\n    ['b', 0],\r\n    ['c', 0],\r\n    ['d', 0],\r\n    ['e', 0],\r\n    ['f', 0],\r\n    ['g', 0],\r\n    ['h', 0],\r\n    ['i', 0],\r\n    ['j', 0],\r\n    ['k', 0],\r\n    ['l', 0],\r\n    ['m', 0],\r\n    ['n', 0],\r\n    ['o', 0],\r\n    ['p', 0],\r\n    ['q', 0],\r\n    ['r', 0],\r\n    ['s', 0],\r\n    ['t', 0],\r\n    ['u', 0],\r\n    ['v', 0],\r\n    ['w', 0],\r\n    ['x', 0],\r\n    ['y', 0],\r\n    ['z', 0],\r\n\r\n    ['A', 0],\r\n    ['B', 0],\r\n    ['C', 0],\r\n    ['D', 0],\r\n    ['E', 0],\r\n    ['F', 0],\r\n    ['G', 0],\r\n    ['H', 0],\r\n    ['I', 0],\r\n    ['J', 0],\r\n    ['K', 0],\r\n    ['L', 0],\r\n    ['M', 0],\r\n    ['N', 0],\r\n    ['O', 0],\r\n    ['P', 0],\r\n    ['Q', 0],\r\n    ['R', 0],\r\n    ['S', 0],\r\n    ['T', 0],\r\n    ['U', 0],\r\n    ['V', 0],\r\n    ['W', 0],\r\n    ['X', 0],\r\n    ['Y', 0],\r\n    ['Z', 0],\r\n\r\n    ['pi', Math.PI],\r\n    ['π', Math.PI],\r\n\r\n    ['phi', (1+Math.sqrt(5))/2],\r\n    ['φ', (1+Math.sqrt(5))/2]\r\n  ]);\r\n}\r\n\r\n","\r\n\r\nexport {Expression} from './Expression'\r\nexport {Variables} from './Variables'","\r\n\r\nexport * from './core'\r\nexport * from './operators'\r\nexport * from './operands'\r\n\r\n","import {OperandAbstract} from \"../abstract/OperandAbstract\";\r\n\r\n\r\nexport class Constant extends OperandAbstract {\r\n\r\n  value: number;\r\n\r\n  constructor(value: number, brackets?: boolean) {\r\n    super(brackets);\r\n    this.value = value;\r\n  }\r\n\r\n  evaluate(): number {\r\n    return this.value;\r\n  }\r\n\r\n  toString(): string {\r\n    let str = this.value.toString();\r\n    if(this.brackets)\r\n      str = \"(\"+str+\")\";\r\n    return str;\r\n  }\r\n}","import {OperandAbstract} from \"../abstract/OperandAbstract\";\r\nimport {Variables} from \"../core\";\r\n\r\n\r\nexport class Variable extends OperandAbstract {\r\n  private identifier: string\r\n  readonly precedence: number = 20;\r\n\r\n  constructor(identifier: string, brackets?: boolean, value?: number) {\r\n    super(brackets);\r\n    this.identifier = identifier;\r\n    if(value !== undefined)\r\n      Variables.map.set(this.identifier, value);\r\n  }\r\n\r\n  evaluate(): number {\r\n    let val = Variables.map.get(this.identifier);\r\n    if(val == undefined)\r\n      val = 0;\r\n    return val;\r\n  }\r\n\r\n  toString(): string {\r\n    let str = this.identifier.toString();\r\n    if(this.brackets)\r\n      str = \"(\"+str+\")\";\r\n    return str;\r\n  }\r\n}\r\n","\r\n\r\nexport {Constant} from './Constant'\r\nexport {Variable} from './Variable'","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {DivisionByZeroException} from \"../../../exceptions/DivisionByZeroException\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class DivideOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"/\");\r\n  readonly names: Array<string> = DivideOperator.names;\r\n  readonly precedence: number = 13;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    if(right.value == 0)\r\n      throw new DivisionByZeroException();\r\n\r\n    return left.value/right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class ExponentOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"^\");\r\n  readonly names: Array<string> = ExponentOperator.names;\r\n  readonly precedence: number = 14;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return Math.pow(left.value, right.value);\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class MinusOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"-\");\r\n  readonly names: Array<string> = MinusOperator.names;\r\n  readonly precedence: number = 12;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value-right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class MultiplyOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"*\");\r\n  readonly names: Array<string> = MultiplyOperator.names;\r\n  readonly precedence: number = 13;\r\n  hidden: boolean = false;\r\n\r\n  constructor(hidden?: boolean) {\r\n    super();\r\n    this.hidden = hidden;\r\n  }\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value*right.value;\r\n  }\r\n\r\n  toString(nameId?: number): string {\r\n    if(!this.hidden)\r\n      return super.toString(nameId);\r\n    return \"\";\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class PlusOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"+\");\r\n  readonly names: Array<string> = PlusOperator.names;\r\n  readonly precedence: number = 12;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value+right.value;\r\n  }\r\n}","\r\n\r\nexport {DivideOperator} from './Divide.operator'\r\nexport {ExponentOperator} from './Exponent.operator'\r\nexport {MinusOperator} from './Minus.operator'\r\nexport {MultiplyOperator} from './Multiply.operator'\r\nexport {PlusOperator} from './Plus.operator'\r\n","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class AndOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"&\");\r\n  readonly names: Array<string> = AndOperator.names;\r\n  readonly precedence: number = 8;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value & right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class OrOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"|\");\r\n  readonly names: Array<string> = OrOperator.names;\r\n  readonly precedence: number = 6;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value | right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class XorOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"||\");\r\n  readonly names: Array<string> = XorOperator.names;\r\n  readonly precedence: number = 7;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value ^ right.value;\r\n  }\r\n}","\r\n\r\nexport {AndOperator} from './And.operator'\r\nexport {OrOperator} from './Or.operator'\r\nexport {XorOperator} from './Xor.operator'\r\n","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class CosOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"cos\");\r\n  readonly names: Array<string> = CosOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.cos(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class LnOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"ln\");\r\n  readonly names: Array<string> = LnOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.log(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class LogOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"log\");\r\n  readonly names: Array<string> = LogOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.log10(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class SinOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"sin\");\r\n  readonly names: Array<string> = SinOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.sin(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class SquareRootOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"sqrt\", \"√\");\r\n  readonly names: Array<string> = SquareRootOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.sqrt(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class TanOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"tan\");\r\n  readonly names: Array<string> = TanOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.tan(result);\r\n  }\r\n}","\r\n\r\nexport {CosOperator} from './Cos.operator'\r\nexport {LnOperator} from './Ln.operator'\r\nexport {LogOperator} from './Log.operator'\r\nexport {SinOperator} from './Sin.operator'\r\nexport {SquareRootOperator} from './SquareRoot.operator'\r\nexport {TanOperator} from './Tan.operator'\r\n","\r\n\r\nexport * from './arithmetic'\r\nexport * from './bitwise'\r\nexport * from './function'\r\n","\r\nexport {ExpressionBuilder} from './core/ExpressionBuilder'\r\nexport {ExpressionParser} from './core/ExpressionParser'\r\n\r\nexport * from './expression'","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"names":["root","factory","exports","module","define","amd","this","constructor","terms","expression","Expression","concat","brackets","add","term","index","undefined","splice","push","length","addAll","remove","getExpression","clear","OperatorKeys","Object","keys","Operators","ExpressionParser","expressionStr","setExpressionStr","parse","UndefinedExpressionStringException","EmptyExpressionStringException","matches","match","leftBrackets","filter","value","rightBrackets","BracketsMissmatchException","exp","expStack","Array","forEach","elem","currentExp","parseElem","ParserException","pop","static","currentExpression","Constant","parseFloat","MultiplyOperator","key","Operator","name","names","Variable","message","super","DivisionByZeroException","EvaluateException","EmptyExpressionException","Error","MissingOperandException","MissingTermException","OperandAbstract","TermAbstract","precedence","_brackets","active","OperatorAbstract","toString","nameId","id","OperatorFunctionAbstract","OperatorLeftRightAbstract","_terms","evaluate","Log","temp","clone","tempStr","highest","highestId","t","evaluateTerm","left","leftValue","right","param","args","debug","console","log","apply","str","Variables","map","Map","Math","PI","sqrt","identifier","set","val","get","DivideOperator","ExponentOperator","pow","MinusOperator","hidden","PlusOperator","AndOperator","OrOperator","XorOperator","CosOperator","result","cos","LnOperator","LogOperator","log10","SinOperator","sin","SquareRootOperator","TanOperator","tan","ExpressionBuilder","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}
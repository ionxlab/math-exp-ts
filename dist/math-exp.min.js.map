{"version":3,"file":"math-exp.min.js","mappings":"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","sources":["webpack://math-exp/webpack/universalModuleDefinition","webpack://math-exp/./src/core/ExpressionBuilder.ts","webpack://math-exp/./src/core/ExpressionParser.ts","webpack://math-exp/./src/exceptions/BracketsMissmatchException.ts","webpack://math-exp/./src/exceptions/DivisionByZeroException.ts","webpack://math-exp/./src/exceptions/EmptyExpressionException.ts","webpack://math-exp/./src/exceptions/EmptyExpressionStringException.ts","webpack://math-exp/./src/exceptions/EvaluateException.ts","webpack://math-exp/./src/exceptions/MissingOperandException.ts","webpack://math-exp/./src/exceptions/MissingTermException.ts","webpack://math-exp/./src/exceptions/ParserException.ts","webpack://math-exp/./src/exceptions/UndefinedExpressionStringException.ts","webpack://math-exp/./src/expression/abstract/OperandAbstract.ts","webpack://math-exp/./src/expression/abstract/OperatorAbstract.ts","webpack://math-exp/./src/expression/abstract/OperatorFunctionAbstract.ts","webpack://math-exp/./src/expression/abstract/OperatorLeftRightAbstract.ts","webpack://math-exp/./src/expression/abstract/TermAbstract.ts","webpack://math-exp/./src/expression/core/Expression.ts","webpack://math-exp/./src/expression/core/Variables.ts","webpack://math-exp/./src/expression/core/index.ts","webpack://math-exp/./src/expression/index.ts","webpack://math-exp/./src/expression/operands/Constant.ts","webpack://math-exp/./src/expression/operands/Variable.ts","webpack://math-exp/./src/expression/operands/index.ts","webpack://math-exp/./src/expression/operators/arithmetic/Divide.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Exponent.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Minus.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Multiply.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/Plus.operator.ts","webpack://math-exp/./src/expression/operators/arithmetic/index.ts","webpack://math-exp/./src/expression/operators/bitwise/And.operator.ts","webpack://math-exp/./src/expression/operators/bitwise/Or.operator.ts","webpack://math-exp/./src/expression/operators/bitwise/Xor.operator.ts","webpack://math-exp/./src/expression/operators/bitwise/index.ts","webpack://math-exp/./src/expression/operators/function/Cos.operator.ts","webpack://math-exp/./src/expression/operators/function/Ln.operator.ts","webpack://math-exp/./src/expression/operators/function/Log.operator.ts","webpack://math-exp/./src/expression/operators/function/Sin.operator.ts","webpack://math-exp/./src/expression/operators/function/SquareRoot.operator.ts","webpack://math-exp/./src/expression/operators/function/Tan.operator.ts","webpack://math-exp/./src/expression/operators/function/index.ts","webpack://math-exp/./src/expression/operators/index.ts","webpack://math-exp/./src/index.ts","webpack://math-exp/webpack/bootstrap","webpack://math-exp/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"math-exp\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"math-exp\"] = factory();\n\telse\n\t\troot[\"math-exp\"] = factory();\n})(this, function() {\nreturn ","import {TermAbstract} from \"../expression/abstract/TermAbstract\";\r\nimport {Expression} from \"../expression\";\r\n\r\n\r\nexport class ExpressionBuilder {\r\n\r\n  private expression: Expression = new Expression();\r\n\r\n  constructor(...terms: TermAbstract[]) {\r\n    this.expression.terms = this.expression.terms.concat(terms);\r\n    this.expression.brackets = false;\r\n  }\r\n\r\n  add(term: TermAbstract, index?: number): number {\r\n    if(index!==undefined)\r\n      this.expression.terms.splice(index, 0, term);\r\n    else\r\n      this.expression.terms.push(term);\r\n\r\n    return this.expression.terms.length;\r\n  }\r\n\r\n  addAll(...terms: TermAbstract[]) {\r\n    this.expression.terms = this.expression.terms.concat(terms);\r\n  }\r\n\r\n  remove(index): Expression {\r\n    if(index>=0 && index<this.expression.terms.length)\r\n      this.expression.terms.splice(index, 1);\r\n\r\n    return this.expression;\r\n  }\r\n\r\n  getExpression(): Expression {\r\n    return this.expression;\r\n  }\r\n\r\n  clear() {\r\n    this.expression.terms = [];\r\n  }\r\n}","import {Expression} from \"../expression\";\r\nimport {Constant, Variable} from \"../expression\";\r\nimport * as Operators from \"../expression/operators\";\r\nimport {BracketsMissmatchException} from \"../exceptions/BracketsMissmatchException\";\r\nimport {TermAbstract} from \"../expression/abstract/TermAbstract\";\r\nimport {EmptyExpressionStringException} from \"../exceptions/EmptyExpressionStringException\";\r\nimport {UndefinedExpressionStringException} from \"../exceptions/UndefinedExpressionStringException\";\r\nimport {ParserException} from \"../exceptions/ParserException\";\r\n\r\nconst OperatorKeys = Object.keys(Operators);\r\n\r\nexport class ExpressionParser {\r\n  private expressionStr: (string | undefined);\r\n\r\n  constructor(expressionStr?: string) {\r\n    this.expressionStr = expressionStr;\r\n  }\r\n\r\n  getExpressionStr() {\r\n    return this.expressionStr;\r\n  }\r\n\r\n  setExpressionStr(expressionStr: string) {\r\n    this.expressionStr = expressionStr;\r\n  }\r\n\r\n  parse(expressionStr?: string): Expression {\r\n    if(expressionStr !== undefined)\r\n      this.expressionStr = expressionStr;\r\n\r\n    // check expression string\r\n    if(!this.expressionStr)\r\n      throw new UndefinedExpressionStringException();\r\n    if(this.expressionStr == \"\")\r\n      throw new EmptyExpressionStringException();\r\n\r\n    // parse all elements from expression string\r\n    const matches = this.expressionStr.match(/\\d+|[a-z]+|[+\\-*\\/()^]|[&|]+/gi);\r\n\r\n    // check number of brackets\r\n    const leftBrackets = matches.filter(value => value=='(');\r\n    const rightBrackets = matches.filter(value => value==')');\r\n    if(leftBrackets.length !== rightBrackets.length)\r\n      throw new BracketsMissmatchException();\r\n\r\n    // create a depth array for nested expressions\r\n    let exp = new Expression();\r\n    const expStack = new Array<Expression>();\r\n    expStack.push(exp);\r\n\r\n    // iterate over all expression term elements\r\n    matches.forEach((elem, index) => {\r\n      const currentExp = expStack[expStack.length-1];\r\n\r\n      // parse elem and return a TermAbstract\r\n      const term = ExpressionParser.parseElem(elem, currentExp);\r\n      if(!term)\r\n        throw new ParserException(\"Unknown element: [\"+elem+\"]\");\r\n\r\n      // if term is an Expression\r\n      if(term instanceof Expression) {\r\n        // if expression is not the current expression, push to expression stack\r\n        if(term !== currentExp) {\r\n          expStack.push(term);\r\n        // else the expression is closed, remove from stack\r\n        } else {\r\n          expStack.pop();\r\n        }\r\n      }\r\n    });\r\n\r\n    return exp;\r\n  }\r\n\r\n  private static parseElem(elem: string, currentExpression: Expression): TermAbstract {\r\n    let term;\r\n\r\n    // if elem matches a numerical constant [0-9]+\r\n    let match = elem.match(/^\\d+$/i);\r\n    if(match) {\r\n      term = new Constant(parseFloat(elem));\r\n      currentExpression.terms.push(term);\r\n      return term;\r\n    }\r\n\r\n    // if elem matches a left bracket\r\n    match = elem.match(/^\\($/i);\r\n    if(match) {\r\n      term = new Expression();\r\n      currentExpression.terms.push(term);\r\n      return term;\r\n    }\r\n\r\n    // if elem matches a right bracket\r\n    match = elem.match(/^\\)$/i);\r\n    if(match) {\r\n      return currentExpression;\r\n    }\r\n\r\n    // if match a named variable\r\n    match = elem.match(/^([a-z]+|[+\\-*\\/^]|[&|]+)$/i);\r\n    if(match) {\r\n\r\n      // if elem matches an operator\r\n      // iterate over all operators\r\n      for(const key of OperatorKeys){\r\n        const Operator = Operators[key];\r\n        // iterate over all operator names\r\n        for(const name of Operator.names) {\r\n          // if name matches, return the constructed operator\r\n          if(name === match[1]) {\r\n            term = new Operators[key]();\r\n            currentExpression.terms.push(term);\r\n            return term;\r\n          }\r\n        }\r\n      }\r\n\r\n      // it's just a variable\r\n      term = new Variable(match[1]);\r\n      currentExpression.terms.push(term);\r\n      return term;\r\n    }\r\n  }\r\n}\r\n","import {ParserException} from \"./ParserException\";\r\n\r\nexport class BracketsMissmatchException extends ParserException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {EvaluateException} from \"./EvaluateException\";\r\n\r\nexport class DivisionByZeroException extends EvaluateException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {EvaluateException} from \"./EvaluateException\";\r\n\r\nexport class EmptyExpressionException extends EvaluateException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {ParserException} from \"./ParserException\";\r\n\r\nexport class EmptyExpressionStringException extends ParserException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","\r\n\r\nexport class EvaluateException extends Error {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {MissingTermException} from \"./MissingTermException\";\r\n\r\nexport class MissingOperandException extends MissingTermException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {EvaluateException} from \"./EvaluateException\";\r\n\r\nexport class MissingTermException extends EvaluateException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","\r\n\r\nexport class ParserException extends Error {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {ParserException} from \"./ParserException\";\r\n\r\nexport class UndefinedExpressionStringException extends ParserException {\r\n\r\n  constructor(message?: string) {\r\n    super(message);\r\n  }\r\n}","import {TermAbstract} from \"./TermAbstract\";\r\n\r\n\r\nexport abstract class OperandAbstract extends TermAbstract {\r\n\r\n  readonly precedence: number = 0;\r\n  protected _brackets: boolean = false;\r\n\r\n  constructor(brackets?: boolean) {\r\n    super();\r\n    if(brackets !== undefined)\r\n      this._brackets = brackets;\r\n  }\r\n\r\n  get brackets() {\r\n    return this._brackets;\r\n  }\r\n\r\n  set brackets(active: boolean) {\r\n    this._brackets = active;\r\n  }\r\n\r\n  abstract evaluate(): number ;\r\n}","import {TermAbstract} from \"./TermAbstract\";\r\n\r\n\r\nexport abstract class OperatorAbstract extends TermAbstract {\r\n\r\n  abstract readonly names: Array<string>;\r\n\r\n  toString(nameId?:number): string {\r\n    let id = 0;\r\n    if(nameId !== undefined && nameId >= 0 && nameId < this.names.length)\r\n      id = 0;\r\n    return this.names[id];\r\n  };\r\n}","import {OperatorAbstract} from \"./OperatorAbstract\";\r\nimport {Constant} from \"../operands\";\r\n\r\nexport abstract class OperatorFunctionAbstract extends OperatorAbstract {\r\n\r\n  readonly precedence: number = 18;\r\n\r\n  abstract evaluate(param: Constant): number ;\r\n}","import {OperatorAbstract} from \"./OperatorAbstract\";\r\nimport {Constant} from \"../operands\";\r\n\r\nexport abstract class OperatorLeftRightAbstract extends OperatorAbstract {\r\n\r\n  abstract evaluate(left: Constant, right: Constant): number ;\r\n}","\r\n\r\nexport abstract class TermAbstract {\r\n\r\n  abstract readonly precedence: number;\r\n  abstract toString(nameId?: number): string;\r\n}","import {OperatorAbstract} from \"../abstract/OperatorAbstract\";\r\nimport {OperandAbstract} from \"../abstract/OperandAbstract\";\r\nimport {TermAbstract} from \"../abstract/TermAbstract\";\r\nimport {OperatorLeftRightAbstract} from \"../abstract/OperatorLeftRightAbstract\";\r\nimport {OperatorFunctionAbstract} from \"../abstract/OperatorFunctionAbstract\";\r\nimport {Constant, Variable} from \"../operands\";\r\nimport {MissingTermException} from \"../../exceptions/MissingTermException\";\r\nimport {MissingOperandException} from \"../../exceptions/MissingOperandException\";\r\nimport {EmptyExpressionException} from \"../../exceptions/EmptyExpressionException\";\r\nimport {EvaluateException} from \"../../exceptions/EvaluateException\";\r\n\r\nexport class Expression extends TermAbstract {\r\n  public static debug = false;\r\n  readonly precedence: number = 19;\r\n\r\n  private _brackets: boolean = true;\r\n  private _terms: Array<TermAbstract> = new Array<TermAbstract>();\r\n\r\n  constructor(...terms: TermAbstract[]) {\r\n    super();\r\n    if(terms !== undefined)\r\n      this._terms = this._terms.concat(terms);\r\n  }\r\n\r\n  get terms(): Array<TermAbstract> {\r\n    return this._terms;\r\n  }\r\n\r\n  set terms(value: Array<TermAbstract>) {\r\n    this._terms = value;\r\n  }\r\n\r\n  get brackets() {\r\n    return this._brackets;\r\n  }\r\n\r\n  set brackets(active: boolean) {\r\n    this._brackets = active;\r\n  }\r\n\r\n  evaluate(): number {\r\n\r\n    // check terms\r\n    if(this._terms.length==0)\r\n      throw new EmptyExpressionException();\r\n\r\n    Expression.Log(\"Evaluating:\", this.toString());\r\n\r\n    // make a clone for editing\r\n    let temp = this.clone();\r\n    let tempStr = temp.toString();\r\n\r\n    // loop until one constant is left\r\n    while(temp._terms.length>1 || !(temp._terms[0] instanceof Constant)) {\r\n\r\n      let highest = -1;\r\n      let highestId = -1;\r\n      // iterate over all terms and evaluate highest precedence\r\n      temp._terms.forEach((t, id) => {\r\n        if(t.precedence>highest) {\r\n          highest = t.precedence;\r\n          highestId = id;\r\n        }\r\n      });\r\n      Expression.evaluateTerm(temp, highestId);\r\n      Expression.Log(\"Temporary expression:\", temp.toString());\r\n\r\n      if(temp._terms.length>1 && tempStr === temp.toString())\r\n        throw new EvaluateException(\"Error while evaluating.\");\r\n\r\n      tempStr = temp.toString();\r\n    }\r\n\r\n    return (temp._terms[0] as OperandAbstract).evaluate();\r\n  }\r\n\r\n  private static evaluateTerm(expression: Expression, index: number): Expression {\r\n\r\n    const term = expression._terms[index];\r\n    Expression.Log(\"Evaluating Term:\", term.toString());\r\n\r\n    let value = 0;\r\n    if(!term)\r\n      throw new MissingTermException(\"Term at '\"+index+\"' is missing.\");\r\n\r\n    if(term instanceof Expression) {\r\n      Expression.Log(\"Term is an 'Expression'\");\r\n      value = term.evaluate();\r\n      expression._terms[index] = new Constant(value, true);\r\n\r\n      // handle coefficients\r\n      const left = expression._terms[index-1];\r\n      if(left instanceof Expression || left instanceof OperandAbstract) {\r\n        const leftValue = left.evaluate();\r\n\r\n        expression._terms[index] = new Constant(value*leftValue);\r\n        expression._terms.splice(index-1, 1);\r\n      }\r\n\r\n    } else if(term instanceof OperandAbstract) {\r\n      if(term instanceof Constant)\r\n        Expression.Log(\"Term is a 'Constant'\");\r\n      if(term instanceof Variable)\r\n        Expression.Log(\"Term is a 'Variable'\");\r\n\r\n      value = term.evaluate();\r\n      expression._terms[index] = new Constant(value, term.brackets);\r\n\r\n    } else if(term instanceof OperatorAbstract) {\r\n\r\n      if(term instanceof OperatorLeftRightAbstract) {\r\n        Expression.Log(\"Term is an 'OperatorLeftRight'\");\r\n        const left = expression._terms[index-1];\r\n        const right = expression._terms[index+1];\r\n\r\n        if(!(left instanceof Constant))\r\n          throw new MissingOperandException(\"Operator '\"+term.toString()+\"' left argument '\"+left.toString()+\"' is invalid.\");\r\n        if(!(right instanceof Constant))\r\n          throw new MissingOperandException(\"Operator '\"+term.toString()+\"' right argument '\"+right.toString()+\"' is invalid.\");\r\n\r\n        value = term.evaluate(left, right);\r\n\r\n        Expression.Log(\"Evaluated Value: \", value);\r\n\r\n        expression._terms[index] = new Constant(value);\r\n        expression._terms.splice(index+1, 1);\r\n        expression._terms.splice(index-1, 1);\r\n\r\n      } else if(term instanceof OperatorFunctionAbstract) {\r\n        Expression.Log(\"Term is an 'OperatorFunction'\");\r\n        const param = expression._terms[index+1];\r\n\r\n        if(!(param instanceof Constant))\r\n          throw new MissingOperandException(\"Operator '\"+term.toString()+\"' argument '\"+param.toString()+\"' is invalid.\");\r\n\r\n        value = term.evaluate(param);\r\n        expression._terms[index] = new Constant(value);\r\n        expression._terms.splice(index+1, 1);\r\n      } else {\r\n        Expression.Log(\"Unknown operator term ?\");\r\n      }\r\n    } else {\r\n      Expression.Log(\"Unknown term ?\");\r\n    }\r\n\r\n    return expression;\r\n  }\r\n\r\n  private static Log(...args: Object[]) {\r\n    if(Expression.debug)\r\n      console.log.apply(console, args);\r\n  }\r\n\r\n  clone(): Expression {\r\n    let clone = new Expression();\r\n    clone.brackets = this.brackets;\r\n    clone._terms = clone._terms.concat(this._terms);\r\n    return clone;\r\n  }\r\n\r\n  toString(): string {\r\n    let str = \"\";\r\n    this._terms.forEach((t, id) => {\r\n      str += t.toString();\r\n    });\r\n    if(this.brackets)\r\n      str = \"(\"+str+\")\";\r\n    return str;\r\n  }\r\n}","\r\n\r\nexport class Variables {\r\n  static map =  new Map<string, number>([\r\n    ['a', 0],\r\n    ['b', 0],\r\n    ['c', 0],\r\n    ['d', 0],\r\n    ['e', 0],\r\n    ['f', 0],\r\n    ['g', 0],\r\n    ['h', 0],\r\n    ['i', 0],\r\n    ['j', 0],\r\n    ['k', 0],\r\n    ['l', 0],\r\n    ['m', 0],\r\n    ['n', 0],\r\n    ['o', 0],\r\n    ['p', 0],\r\n    ['q', 0],\r\n    ['r', 0],\r\n    ['s', 0],\r\n    ['t', 0],\r\n    ['u', 0],\r\n    ['v', 0],\r\n    ['w', 0],\r\n    ['x', 0],\r\n    ['y', 0],\r\n    ['z', 0],\r\n\r\n    ['A', 0],\r\n    ['B', 0],\r\n    ['C', 0],\r\n    ['D', 0],\r\n    ['E', 0],\r\n    ['F', 0],\r\n    ['G', 0],\r\n    ['H', 0],\r\n    ['I', 0],\r\n    ['J', 0],\r\n    ['K', 0],\r\n    ['L', 0],\r\n    ['M', 0],\r\n    ['N', 0],\r\n    ['O', 0],\r\n    ['P', 0],\r\n    ['Q', 0],\r\n    ['R', 0],\r\n    ['S', 0],\r\n    ['T', 0],\r\n    ['U', 0],\r\n    ['V', 0],\r\n    ['W', 0],\r\n    ['X', 0],\r\n    ['Y', 0],\r\n    ['Z', 0],\r\n\r\n    ['pi', Math.PI],\r\n    ['π', Math.PI],\r\n\r\n    ['phi', (1+Math.sqrt(5))/2],\r\n    ['φ', (1+Math.sqrt(5))/2]\r\n  ]);\r\n}\r\n\r\n","\r\n\r\nexport {Expression} from './Expression'\r\nexport {Variables} from './Variables'","\r\n\r\nexport * from './core'\r\nexport * from './operators'\r\nexport * from './operands'\r\n\r\n","import {OperandAbstract} from \"../abstract/OperandAbstract\";\r\n\r\n\r\nexport class Constant extends OperandAbstract {\r\n\r\n  value: number;\r\n\r\n  constructor(value: number, brackets?: boolean) {\r\n    super(brackets);\r\n    this.value = value;\r\n  }\r\n\r\n  evaluate(): number {\r\n    return this.value;\r\n  }\r\n\r\n  toString(): string {\r\n    let str = this.value.toString();\r\n    if(this.brackets)\r\n      str = \"(\"+str+\")\";\r\n    return str;\r\n  }\r\n}","import {OperandAbstract} from \"../abstract/OperandAbstract\";\r\nimport {Variables} from \"../core\";\r\n\r\n\r\nexport class Variable extends OperandAbstract {\r\n  private identifier: string\r\n  readonly precedence: number = 20;\r\n\r\n  constructor(identifier: string, brackets?: boolean, value?: number) {\r\n    super(brackets);\r\n    this.identifier = identifier;\r\n    if(value !== undefined)\r\n      Variables.map.set(this.identifier, value);\r\n  }\r\n\r\n  evaluate(): number {\r\n    let val = Variables.map.get(this.identifier);\r\n    if(val == undefined)\r\n      val = 0;\r\n    return val;\r\n  }\r\n\r\n  toString(): string {\r\n    let str = this.identifier.toString();\r\n    if(this.brackets)\r\n      str = \"(\"+str+\")\";\r\n    return str;\r\n  }\r\n}\r\n","\r\n\r\nexport {Constant} from './Constant'\r\nexport {Variable} from './Variable'","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {DivisionByZeroException} from \"../../../exceptions/DivisionByZeroException\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class DivideOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"/\");\r\n  readonly names: Array<string> = DivideOperator.names;\r\n  readonly precedence: number = 13;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    if(right.value == 0)\r\n      throw new DivisionByZeroException();\r\n\r\n    return left.value/right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class ExponentOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"^\");\r\n  readonly names: Array<string> = ExponentOperator.names;\r\n  readonly precedence: number = 14;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return Math.pow(left.value, right.value);\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class MinusOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"-\");\r\n  readonly names: Array<string> = MinusOperator.names;\r\n  readonly precedence: number = 12;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value-right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class MultiplyOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"*\");\r\n  readonly names: Array<string> = MultiplyOperator.names;\r\n  readonly precedence: number = 13;\r\n  hidden: boolean = false;\r\n\r\n  constructor(hidden?: boolean) {\r\n    super();\r\n    this.hidden = hidden;\r\n  }\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value*right.value;\r\n  }\r\n\r\n  toString(nameId?: number): string {\r\n    if(!this.hidden)\r\n      return super.toString(nameId);\r\n    return \"\";\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class PlusOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"+\");\r\n  readonly names: Array<string> = PlusOperator.names;\r\n  readonly precedence: number = 12;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value+right.value;\r\n  }\r\n}","\r\n\r\nexport {DivideOperator} from './Divide.operator'\r\nexport {ExponentOperator} from './Exponent.operator'\r\nexport {MinusOperator} from './Minus.operator'\r\nexport {MultiplyOperator} from './Multiply.operator'\r\nexport {PlusOperator} from './Plus.operator'\r\n","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class AndOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"&\");\r\n  readonly names: Array<string> = AndOperator.names;\r\n  readonly precedence: number = 8;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value & right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class OrOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"|\");\r\n  readonly names: Array<string> = OrOperator.names;\r\n  readonly precedence: number = 6;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value | right.value;\r\n  }\r\n}","import {OperatorLeftRightAbstract} from \"../../abstract/OperatorLeftRightAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class XorOperator extends OperatorLeftRightAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"||\");\r\n  readonly names: Array<string> = XorOperator.names;\r\n  readonly precedence: number = 7;\r\n\r\n  evaluate(left: Constant, right: Constant): number {\r\n    return left.value ^ right.value;\r\n  }\r\n}","\r\n\r\nexport {AndOperator} from './And.operator'\r\nexport {OrOperator} from './Or.operator'\r\nexport {XorOperator} from './Xor.operator'\r\n","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class CosOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"cos\");\r\n  readonly names: Array<string> = CosOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.cos(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class LnOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"ln\");\r\n  readonly names: Array<string> = LnOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.log(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class LogOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"log\");\r\n  readonly names: Array<string> = LogOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.log10(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class SinOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"sin\");\r\n  readonly names: Array<string> = SinOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.sin(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class SquareRootOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"sqrt\", \"√\");\r\n  readonly names: Array<string> = SquareRootOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.sqrt(result);\r\n  }\r\n}","import {OperatorFunctionAbstract} from \"../../abstract/OperatorFunctionAbstract\";\r\nimport {Constant} from \"../../operands\";\r\n\r\nexport class TanOperator extends OperatorFunctionAbstract {\r\n\r\n  static readonly names: Array<string> = new Array<string>(\"tan\");\r\n  readonly names: Array<string> = TanOperator.names;\r\n\r\n  evaluate(param: Constant): number {\r\n    const result = param.evaluate();\r\n    return Math.tan(result);\r\n  }\r\n}","\r\n\r\nexport {CosOperator} from './Cos.operator'\r\nexport {LnOperator} from './Ln.operator'\r\nexport {LogOperator} from './Log.operator'\r\nexport {SinOperator} from './Sin.operator'\r\nexport {SquareRootOperator} from './SquareRoot.operator'\r\nexport {TanOperator} from './Tan.operator'\r\n","\r\n\r\nexport * from './arithmetic'\r\nexport * from './bitwise'\r\nexport * from './function'\r\n","\r\nexport {ExpressionBuilder} from './core/ExpressionBuilder'\r\nexport {ExpressionParser} from './core/ExpressionParser'\r\n\r\nexport * from './expression'","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"names":["root","factory","exports","module","define","amd","this","constructor","terms","expression","Expression","concat","brackets","add","term","index","undefined","splice","push","length","addAll","remove","getExpression","clear","OperatorKeys","Object","keys","Operators","ExpressionParser","expressionStr","getExpressionStr","setExpressionStr","parse","UndefinedExpressionStringException","EmptyExpressionStringException","matches","match","leftBrackets","filter","value","rightBrackets","BracketsMissmatchException","exp","expStack","Array","forEach","elem","currentExp","parseElem","ParserException","pop","static","currentExpression","Constant","parseFloat","key","Operator","name","names","Variable","message","super","DivisionByZeroException","EvaluateException","EmptyExpressionException","Error","MissingOperandException","MissingTermException","OperandAbstract","TermAbstract","precedence","_brackets","active","OperatorAbstract","toString","nameId","id","OperatorFunctionAbstract","OperatorLeftRightAbstract","_terms","evaluate","Log","temp","clone","tempStr","highest","highestId","t","evaluateTerm","left","leftValue","right","param","args","debug","console","log","apply","str","Variables","map","Map","Math","PI","sqrt","identifier","set","val","get","DivideOperator","ExponentOperator","pow","MinusOperator","MultiplyOperator","hidden","PlusOperator","AndOperator","OrOperator","XorOperator","CosOperator","result","cos","LnOperator","LogOperator","log10","SinOperator","sin","SquareRootOperator","TanOperator","tan","ExpressionBuilder","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}